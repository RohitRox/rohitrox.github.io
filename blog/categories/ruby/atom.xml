<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Blog @ RohitRox]]></title>
  <link href="http://rohitrox.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rohitrox.github.io/"/>
  <updated>2013-08-19T01:36:45+05:45</updated>
  <id>http://rohitrox.github.io/</id>
  <author>
    <name><![CDATA[Rohit Rox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Dynamic Methods]]></title>
    <link href="http://rohitrox.github.io/2013/07/02/ruby-dynamic-methods/"/>
    <updated>2013-07-02T11:27:00+05:45</updated>
    <id>http://rohitrox.github.io/2013/07/02/ruby-dynamic-methods</id>
    <content type="html"><![CDATA[<p>We define methods using <strong><em>def</em></strong> keywords which is fine for most of the cases.</p>

<p>But consider a situation where you have to create a series of methods all of which have the same basic structure and logic then it seems repititive and not dry.</p>

<p>Ruby, being a dynamic language, you can create methods on the fly.</p>

<p>So, what does that mean?</p>

<p>lets see this simplest example:</p>

<p>``` ruby</p>

<p>  class A</p>

<pre><code>define_method :a do
  puts "hello"
end

define_method :greeting do |message|
  puts message
end
</code></pre>

<p>  end</p>

<p>  A.new.a #=> hello
  A.new.greeting &lsquo;Ram ram&rsquo; #=> Ram ram</p>

<p>```</p>

<!--more-->


<p>The <strong><em>define_method</em></strong> defines an instance method in the receiver. The syntax and usage are self-explained in the example above.</p>

<p>lets see following example that may be useful in practical scenarios.</p>

<p>``` ruby</p>

<p>  class User</p>

<pre><code>ACTIVE = 0
INACTIVE = 1
PENDING = 2

attr_accessor :status

def active?
  status == ACTIVE
end

def inactive?
  status == User::INACTIVE
end

def pending?
  status == User::PENDING
end
</code></pre>

<p>  end</p>

<p>  user = User.new
  user.status = 1</p>

<p>  user.inactive?
  #=> true
  user.active?
  #=> false</p>

<p>```</p>

<p>Refactored code using dynamic method definition:</p>

<p>``` ruby</p>

<p>  class User</p>

<pre><code>ACTIVE = 0
INACTIVE = 1
PENDING = 2

attr_accessor :status

[:active, :inactive, :pending].each do |method|
  define_method "#{method}?" do
    status == User.const_get(method.upcase)
  end
end
</code></pre>

<p>  end</p>

<p>  user = User.new
  user.status = 1</p>

<p>  user.inactive?
  #=> true
  user.active?
  #=> false</p>

<p>```
We use define_method to define method dynamically.</p>

<p>We can also define instance methods with a class method, using this technique we can expose a class method that will generate the  instance methods. COOL !</p>

<p>Example:</p>

<p>``` ruby
  class User</p>

<pre><code>ACTIVE = 0
INACTIVE = 1
PENDING = 2

attr_accessor :status

def self.states(*args)
  args.each do |arg|
    define_method "#{arg}?" do
      self.status == User.const_get(arg.upcase)
    end
  end
end

states :active, :inactive, :pending
</code></pre>

<p>  end</p>

<p>```</p>

<p>Now, what about class methods. The simplest way is</p>

<p>``` ruby</p>

<pre><code>class A
  class &lt;&lt; self
    define_method method_name do
      #...
    end
  end
end
</code></pre>

<p>```
There are <strong><em>instance_eval</em></strong> and <strong><em>class_eval</em></strong> also, which are used for dynamic method definition. These methods allow you to evaluate arbitrary code in the context of a particular class or object. These methods can be very confusing sometimes. You can read <a href="http://stackoverflow.com/questions/900419/how-to-understand-the-difference-between-class-eval-and-instance-eval">this</a> discussion and <a href="http://www.ploughthroughruby.co.uk/2009/09/30/define_method-instance_eval-and-class_eval.html/">this</a> blog post and understand how they can be used.</p>

<p>From that discussion, we summerize</p>

<p>``` ruby
  Foo = Class.new
  Foo.class_eval do</p>

<pre><code>def class_bar
  "class_bar"
end
</code></pre>

<p>  end
  Foo.instance_eval do</p>

<pre><code>def instance_bar
  "instance_bar"
end
</code></pre>

<p>  end
  Foo.class_bar       #=> undefined method ‘class_bar’ for Foo:Class
  Foo.new.class_bar   #=> &ldquo;class_bar&rdquo;
  Foo.instance_bar       #=> &ldquo;instance_bar&rdquo;
  Foo.new.instance_bar   #=> undefined method ‘instance_bar’ for #&lt;Foo:0x7dce8>
```</p>

<p>Note that, we don&rsquo;t use <strong><em>define_method</em></strong> inside *_eval, becasue it does not matter if you use define_method inside class_eval or instance_eval it would always create an instance method.</p>

<p>And, we get this:</p>

<p>``` ruby
  Foo = Class.new</p>

<p>  Foo.class_eval do</p>

<pre><code>define_method "class_bar" do
  "class_bar"
end
</code></pre>

<p>  end</p>

<p>  Foo.instance_eval do</p>

<pre><code>define_method "instance_bar" do
  "instance_bar"
end
</code></pre>

<p>  end</p>

<p>  Foo.class_bar #=> undefined
  Foo.new.class_bar #=> &ldquo;class_bar&rdquo;
  Foo.instance_bar #=> undefined
  Foo.new.instance_bar #=> &ldquo;instance_bar&rdquo;</p>

<p>```</p>

<p>Next, we can invoke methods dynamically. One way to invoke a method dynamically in ruby is to send a message to the object. We can send a message to a class either within the class definition itself, or by simply sending it to the class object like you’d send any other message. This can be accomplished by usin <strong><em>send</em></strong>.</p>

<p>The simplest example could be:</p>

<p>``` ruby</p>

<p>  s= &ldquo;hi man&rdquo;</p>

<p>  p s.length #=> 6
  p s.include? &ldquo;hi&rdquo; #=> true</p>

<p>  p s.send(:length) #=> 6
  p s.send(:include?,&ldquo;hi&rdquo;) #=> true</p>

<p>```</p>

<p>How can this be ever useful?</p>

<p>Lets see the following code( example taken from <a href="http://www.funonrails.com/2011/12/dynamic-methods-inside-ruby-classes.html">here</a>)</p>

<p>``` ruby</p>

<p>  class ApplicationController &lt; ActionController::Base</p>

<pre><code>protect_from_forgery
helper_method :current_staff, :current_employee, current_admin

def authenticate_staff!(opts={})
  current_staff || not_authorized
end

def current_staff
  current_user if current_user.is_a? Staff
end

def authenticate_employee!(opts={})
  current_employee || not_authorized
end

def current_employee
  current_user if current_user.is_a? Employee
end

def authenticate_admin!(opts={})
  current_admin || not_authorized
end

def current_admin
  current_user if current_user.is_a? Admin
end
</code></pre>

<p>  end</p>

<p>```</p>

<p>And refactored one:</p>

<p>``` ruby
  %w(Staff Employee Admin).each do |k|</p>

<pre><code>define_method "current_#{k.underscore}" do
  current_user if current_user.is_a?(k.constantize)
end

define_method "authenticate_#{k.underscore}!" do |opts={}|
  send("current_#{k.underscore}") || not_authorized
end
</code></pre>

<p>  end
```</p>

<p>Dynamically defined methods can help guard against method definition mistakes, avoid repetitive codes and be concise and smart.</p>

<p>Happy Metaprogramming.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature flippers with rollout]]></title>
    <link href="http://rohitrox.github.io/2013/03/18/feature-flippers-with-rollout/"/>
    <updated>2013-03-18T12:09:00+05:45</updated>
    <id>http://rohitrox.github.io/2013/03/18/feature-flippers-with-rollout</id>
    <content type="html"><![CDATA[<p>Rollout gem comes handy when we need deploy a beta feature, may be to a selected group of users or some percentage of uses so that few users can try it out before it goes massive.</p>

<p>So lets rollout.</p>

<p>First of all, make sure that you have redis, because rollout uses redis as its backend. Then add <code>gem 'rollout'</code> to gemfile and bundle install.</p>

<p>Now, we need to create a rollout setup file inside initializer.</p>

<p>Let&rsquo;s name it rollout_init.rb which looks like this:</p>

<p>```ruby</p>

<p>  $redis = Redis.new
  $rollout = Rollout.new($redis)
  $rollout.define_group(:admin) do |user|</p>

<pre><code>user.admin?
</code></pre>

<p>  end</p>

<p>```
Documentation suggests to use a global variables. So we create one with a new redis instance.
Then, we create rollout instance passsing that redis instance. We can configure rollout in many ways, here we are defining an admin group by passing a block and checking whether the user belongs to that group or not.
Complete documentation can be found <a href="https://github.com/jamesgolick/rollout">here</a>.</p>

<p>Next, we can now use handy rollout method like for example let&rsquo;s say we need to activate chat feature for admin group only.</p>

<p>``` ruby</p>

<p>  if $rollout.active? :chat, current_user</p>

<pre><code>....
</code></pre>

<p>  end</p>

<p>```</p>

<!--more-->


<p>The <code>$rollout.active?</code> method accepts the name of the feature and the user and returns true or false.</p>

<p>This method is accessible in views as well as in controllers.
That&rsquo;s not all, if you restart your server now and look at the app, you may find out that the feature is unavailable to admin groups also, it is because by default the feature is deactivated to all groups or users. We can make a rake task or an interface for activating the feature to subset of users. Activating code looks like this:</p>

<p>``` ruby</p>

<p>  $rollout.activate_group(:chat, :admin)</p>

<p>```
This will activate the feature ( chat in our case ) for admin group.</p>

<p>Also we can activate the feature to all users or specific user or to some percentage.</p>

<p>``` ruby</p>

<p>  $rollout.activate_group( :chat, :all ) #activate to all, there is all group already by default</p>

<p>  $rollout.activate_user( :chat, User.find_by_email(&ldquo;<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x61;&#100;&#109;&#x69;&#110;&#64;&#x6d;&#121;&#x61;&#x70;&#112;&#x2e;&#x63;&#x6f;&#x6d;">&#x61;&#100;&#x6d;&#105;&#110;&#x40;&#109;&#121;&#x61;&#x70;&#112;&#46;&#x63;&#111;&#x6d;</a>&rdquo;) ) #activate to specific user</p>

<p>  $rollout.activate_percantage( :chat, 50 ) #activate to 50% of users</p>

<p>```</p>

<p>Each of these methods have deactivate version for deactivating the feature. You can also just call <code>$rollout.deactivate_all(:chat)</code> to deactivate the feature to all at once.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord with Ruby alone]]></title>
    <link href="http://rohitrox.github.io/2012/10/30/activerecord-with-ruby-alone/"/>
    <updated>2012-10-30T23:06:00+05:45</updated>
    <id>http://rohitrox.github.io/2012/10/30/activerecord-with-ruby-alone</id>
    <content type="html"><![CDATA[<p>Active Record is the main tool that Rails developers use to communicate with and underlying database. Active Record does some wonderful things for a web developer looking for abstractions in  database setup, SQL connections and queries.  We can get a cool command line Ruby application or utility script for our daily tasks using Active Record going in about 5 minutes!</p>

<p>First of all, get the activerecord gem using
```
gem install activerecord</p>

<p>```</p>

<p>At the top of Ruby program we need to require the Active Record gem previously installed.  Interacting with your database will be a pleasure now!
<code>ruby
require 'activerecord'
</code></p>

<h3>Establishing a connection to database</h3>

<p>``` ruby</p>

<p>ActiveRecord::Base.establish_connection {
  :adapter => &ldquo;mysql&rdquo;,
  :host => &ldquo;localhost&rdquo;,
  :username => &ldquo;root&rdquo;,
  :password => &ldquo;password&rdquo;,
  :database => &ldquo;dbname&rdquo;
}</p>

<p>```</p>

<!-- more -->


<p>After successfull database connection we can create a class that inherits from ActiveRecord::Base whose objects map to database a table. Suppose we have users table with name field:
``` ruby</p>

<p>class User &lt; ActiveRecord::Base</p>

<pre><code># this maps database table users to this Ruby class User
</code></pre>

<p>end</p>

<p>User.all # select all from users table
usr = User.first # returns the first object fetched by SELECT * FROM users<br/>
usr.name = &lsquo;zappy&rsquo;
usr.save # name zappy is set for usr and saved in db</p>

<p>```
Active Record objects don’t specify their attributes directly, but rather infer them from the table definition with which they’re linked. Adding, removing, and changing attributes and their type is done directly in the database. Any change is instantly reflected in the Active Record objects. The mapping that binds a given Active Record class to a certain database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.</p>

<p>All the goodness available from ActiveRecord is documented <a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html">here</a>.</p>

<p>It should be noted that there are some conventions it assumes:</p>

<ul>
<li>an Active Record class maps to a database table.</li>
<li>database table names, like variable names, have lowercase letters and underscores between the words.</li>
<li>table names are always plural.
ie.
```
class User &lt; ActiveRecord::Base
end</li>
</ul>


<p>```
looks for database table named users.</p>

<p>If you want table names to be singular instead of plural, you can set the configuration parameter pluralize_table_names:
```</p>

<pre><code>ActiveRecord::Base.pluralize_table_names = false
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interacting to MySQL using Ruby]]></title>
    <link href="http://rohitrox.github.io/2012/10/30/interacting-to-mysql-with-ruby/"/>
    <updated>2012-10-30T00:58:00+05:45</updated>
    <id>http://rohitrox.github.io/2012/10/30/interacting-to-mysql-with-ruby</id>
    <content type="html"><![CDATA[<p>This tutorials guides you to go straight into interacting with MySQL database using Ruby alone. No Rails.
It is assumed that MySQL has been installed in your computer.</p>

<p>Now let&rsquo;s get started:</p>

<p>First of all, lets begin with installing MySQL libraries via RubyGems</p>

<p>``` ruby</p>

<pre><code>sudo gem install mysql
</code></pre>

<p>```
There is <a href="http://www.tmtm.org/en/mysql/ruby/">documentation</a> for the MySQL library online . So you can follow that.</p>

<p>Now let&rsquo;s fire irb.</p>

<p>``` ruby</p>

<pre><code>require 'mysql'
db = Mysql.new('localhost', 'user', 'password', 'database')
</code></pre>

<p>```</p>

<!-- more -->


<p>If you are using something like Lampp you may end up with error like</p>

<p>``` ruby</p>

<pre><code>Mysql::Error: Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)
</code></pre>

<p>```
So you have to locate where your mysqld.sock is.</p>

<p>For Lamp users, it&rsquo;s in
/opt/lampp/var/mysql/mysql.sock
For others you can find by using
ps aux | grep mysql</p>

<p>Next,create symlink at &lsquo;/var/run/mysqld/mysqld.sock&rsquo; to location of mysql.sock by ln -s command.</p>

<p>``` ruby</p>

<pre><code>sudo ln -s /opt/lampp/var/mysql/mysql.sock /var/run/mysqld/mysqld.sock
</code></pre>

<p>```</p>

<p>That&rsquo;s it. Now we are ready to go.
With successfull connection we can query to database.</p>

<p>``` ruby</p>

<pre><code>begin
  results = db.query "SELECT * FROM users"
  puts "Number of users #{results.num_rows}"
  results.each_hash do |row|
    puts "User #{row.id}: #{row.name}"
  end
  results.free
ensure
  db.close
end
</code></pre>

<p>```</p>

<p>The code is wrapped up in an exception handling block, to ensure that no matter what happens in the code. The database connection is closed.</p>

<p>The returned result is of Mysql::Result class.Check the <a href="http://www.tmtm.org/en/mysql/ruby/">documentation</a> and scroll down to Mysql::Result for various methods available at your disposal.If you are familiar with other MySQL connectors, this should be a breeze.</p>

<p>Lastly, Mysql Ruby connector also supports prepared statements, so you can use goodness out of it.</p>

<p>``` ruby</p>

<pre><code>begin
    insert_new_user = db.prepare "INSERT INTO users (name, age, gender) VALUES (?, ? ,?)"
    insert_new_user.execute 'travis', '22', 'male'

    insert_new_user.close

    statement = db.prepare "SELECT * FROM users WHERE name = ?"
    statement.execute 'travis'
    statement.fetch
    statement.close
ensure
    db.close
end
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
