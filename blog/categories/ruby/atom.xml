<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Blog @ RohitRox]]></title>
  <link href="http://rohitrox.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rohitrox.github.io/"/>
  <updated>2013-08-09T02:11:04+05:45</updated>
  <id>http://rohitrox.github.io/</id>
  <author>
    <name><![CDATA[Rohit Rox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Dynamic Methods]]></title>
    <link href="http://rohitrox.github.io/2013/07/02/ruby-dynamic-methods/"/>
    <updated>2013-07-02T11:27:00+05:45</updated>
    <id>http://rohitrox.github.io/2013/07/02/ruby-dynamic-methods</id>
    <content type="html"><![CDATA[<p>We define methods using <strong><em>def</em></strong> keywords which is fine for most of the cases.</p>

<p>But consider a situation where you have to create a series of methods all of which have the same basic structure and logic then it seems repititive and not dry.</p>

<p>Ruby, being a dynamic language, you can create methods on the fly.</p>

<p>So, what does that mean?</p>

<p>lets see this simplest example:</p>

<p>``` ruby</p>

<p>  class A</p>

<pre><code>define_method :a do
  puts "hello"
end

define_method :greeting do |message|
  puts message
end
</code></pre>

<p>  end</p>

<p>  A.new.a #=> hello
  A.new.greeting &lsquo;Ram ram&rsquo; #=> Ram ram</p>

<p>```</p>

<!--more-->


<p>The <strong><em>define_method</em></strong> defines an instance method in the receiver. The syntax and usage are self-explained in the example above.</p>

<p>lets see following example that may be useful in practical scenarios.</p>

<p>``` ruby</p>

<p>  class User</p>

<pre><code>ACTIVE = 0
INACTIVE = 1
PENDING = 2

attr_accessor :status

def active?
  status == ACTIVE
end

def inactive?
  status == User::INACTIVE
end

def pending?
  status == User::PENDING
end
</code></pre>

<p>  end</p>

<p>  user = User.new
  user.status = 1</p>

<p>  user.inactive?
  #=> true
  user.active?
  #=> false</p>

<p>```</p>

<p>Refactored code using dynamic method definition:</p>

<p>``` ruby</p>

<p>  class User</p>

<pre><code>ACTIVE = 0
INACTIVE = 1
PENDING = 2

attr_accessor :status

[:active, :inactive, :pending].each do |method|
  define_method "#{method}?" do
    status == User.const_get(method.upcase)
  end
end
</code></pre>

<p>  end</p>

<p>  user = User.new
  user.status = 1</p>

<p>  user.inactive?
  #=> true
  user.active?
  #=> false</p>

<p>```
We use define_method to define method dynamically.</p>

<p>We can also define instance methods with a class method, using this technique we can expose a class method that will generate the  instance methods. COOL !</p>

<p>Example:</p>

<p>``` ruby
  class User</p>

<pre><code>ACTIVE = 0
INACTIVE = 1
PENDING = 2

attr_accessor :status

def self.states(*args)
  args.each do |arg|
    define_method "#{arg}?" do
      self.status == User.const_get(arg.upcase)
    end
  end
end

states :active, :inactive, :pending
</code></pre>

<p>  end</p>

<p>```</p>

<p>Now, what about class methods. The simplest way is</p>

<p>``` ruby</p>

<pre><code>class A
  class &lt;&lt; self
    define_method method_name do
      #...
    end
  end
end
</code></pre>

<p>```
There are <strong><em>instance_eval</em></strong> and <strong><em>class_eval</em></strong> also, which are used for dynamic method definition. These methods allow you to evaluate arbitrary code in the context of a particular class or object. These methods can be very confusing sometimes. You can read <a href="http://stackoverflow.com/questions/900419/how-to-understand-the-difference-between-class-eval-and-instance-eval">this</a> discussion and <a href="http://www.ploughthroughruby.co.uk/2009/09/30/define_method-instance_eval-and-class_eval.html/">this</a> blog post and understand how they can be used.</p>

<p>From that discussion, we summerize</p>

<p>``` ruby
  Foo = Class.new
  Foo.class_eval do</p>

<pre><code>def class_bar
  "class_bar"
end
</code></pre>

<p>  end
  Foo.instance_eval do</p>

<pre><code>def instance_bar
  "instance_bar"
end
</code></pre>

<p>  end
  Foo.class_bar       #=> undefined method ‘class_bar’ for Foo:Class
  Foo.new.class_bar   #=> &ldquo;class_bar&rdquo;
  Foo.instance_bar       #=> &ldquo;instance_bar&rdquo;
  Foo.new.instance_bar   #=> undefined method ‘instance_bar’ for #&lt;Foo:0x7dce8>
```</p>

<p>Note that, we don&rsquo;t use <strong><em>define_method</em></strong> inside *_eval, becasue it does not matter if you use define_method inside class_eval or instance_eval it would always create an instance method.</p>

<p>And, we get this:</p>

<p>``` ruby
  Foo = Class.new</p>

<p>  Foo.class_eval do</p>

<pre><code>define_method "class_bar" do
  "class_bar"
end
</code></pre>

<p>  end</p>

<p>  Foo.instance_eval do</p>

<pre><code>define_method "instance_bar" do
  "instance_bar"
end
</code></pre>

<p>  end</p>

<p>  Foo.class_bar #=> undefined
  Foo.new.class_bar #=> &ldquo;class_bar&rdquo;
  Foo.instance_bar #=> undefined
  Foo.new.instance_bar #=> &ldquo;instance_bar&rdquo;</p>

<p>```</p>

<p>Next, we can invoke methods dynamically. One way to invoke a method dynamically in ruby is to send a message to the object. We can send a message to a class either within the class definition itself, or by simply sending it to the class object like you’d send any other message. This can be accomplished by usin <strong><em>send</em></strong>.</p>

<p>The simplest example could be:</p>

<p>``` ruby</p>

<p>  s= &ldquo;hi man&rdquo;</p>

<p>  p s.length #=> 6
  p s.include? &ldquo;hi&rdquo; #=> true</p>

<p>  p s.send(:length) #=> 6
  p s.send(:include?,&ldquo;hi&rdquo;) #=> true</p>

<p>```</p>

<p>How can this be ever useful?</p>

<p>Lets see the following code( example taken from <a href="http://www.funonrails.com/2011/12/dynamic-methods-inside-ruby-classes.html">here</a>)</p>

<p>``` ruby</p>

<p>  class ApplicationController &lt; ActionController::Base</p>

<pre><code>protect_from_forgery
helper_method :current_staff, :current_employee, current_admin

def authenticate_staff!(opts={})
  current_staff || not_authorized
end

def current_staff
  current_user if current_user.is_a? Staff
end

def authenticate_employee!(opts={})
  current_employee || not_authorized
end

def current_employee
  current_user if current_user.is_a? Employee
end

def authenticate_admin!(opts={})
  current_admin || not_authorized
end

def current_admin
  current_user if current_user.is_a? Admin
end
</code></pre>

<p>  end</p>

<p>```</p>

<p>And refactored one:</p>

<p>``` ruby
  %w(Staff Employee Admin).each do |k|</p>

<pre><code>define_method "current_#{k.underscore}" do
  current_user if current_user.is_a?(k.constantize)
end

define_method "authenticate_#{k.underscore}!" do |opts={}|
  send("current_#{k.underscore}") || not_authorized
end
</code></pre>

<p>  end
```</p>

<p>Dynamically defined methods can help guard against method definition mistakes, avoid repetitive codes and be concise and smart.</p>

<p>Happy Metaprogramming.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature flippers with rollout]]></title>
    <link href="http://rohitrox.github.io/2013/03/18/feature-flippers-with-rollout/"/>
    <updated>2013-03-18T12:09:00+05:45</updated>
    <id>http://rohitrox.github.io/2013/03/18/feature-flippers-with-rollout</id>
    <content type="html"><![CDATA[<p>Rollout gem comes handy when we need deploy a beta feature, may be to a selected group of users or some percentage of uses so that few users can try it out before it goes massive.</p>

<p>So lets rollout.</p>

<p>First of all, make sure that you have redis, because rollout uses redis as its backend. Then add <code>gem 'rollout'</code> to gemfile and bundle install.</p>

<p>Now, we need to create a rollout setup file inside initializer.</p>

<p>Let&rsquo;s name it rollout_init.rb which looks like this:</p>

<p>```ruby</p>

<p>  $redis = Redis.new
  $rollout = Rollout.new($redis)
  $rollout.define_group(:admin) do |user|</p>

<pre><code>user.admin?
</code></pre>

<p>  end</p>

<p>```
Documentation suggests to use a global variables. So we create one with a new redis instance.
Then, we create rollout instance passsing that redis instance. We can configure rollout in many ways, here we are defining an admin group by passing a block and checking whether the user belongs to that group or not.
Complete documentation can be found <a href="https://github.com/jamesgolick/rollout">here</a>.</p>

<p>Next, we can now use handy rollout method like for example let&rsquo;s say we need to activate chat feature for admin group only.</p>

<p>``` ruby</p>

<p>  if $rollout.active? :chat, current_user</p>

<pre><code>....
</code></pre>

<p>  end</p>

<p>```</p>

<!--more-->


<p>The <code>$rollout.active?</code> method accepts the name of the feature and the user and returns true or false.</p>

<p>This method is accessible in views as well as in controllers.
That&rsquo;s not all, if you restart your server now and look at the app, you may find out that the feature is unavailable to admin groups also, it is because by default the feature is deactivated to all groups or users. We can make a rake task or an interface for activating the feature to subset of users. Activating code looks like this:</p>

<p>``` ruby</p>

<p>  $rollout.activate_group(:chat, :admin)</p>

<p>```
This will activate the feature ( chat in our case ) for admin group.</p>

<p>Also we can activate the feature to all users or specific user or to some percentage.</p>

<p>``` ruby</p>

<p>  $rollout.activate_group( :chat, :all ) #activate to all, there is all group already by default</p>

<p>  $rollout.activate_user( :chat, User.find_by_email(&ldquo;<a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x61;&#100;&#x6d;&#x69;&#x6e;&#x40;&#109;&#x79;&#x61;&#112;&#112;&#x2e;&#99;&#111;&#109;">&#97;&#100;&#109;&#x69;&#110;&#64;&#x6d;&#x79;&#x61;&#x70;&#112;&#x2e;&#99;&#x6f;&#109;</a>&rdquo;) ) #activate to specific user</p>

<p>  $rollout.activate_percantage( :chat, 50 ) #activate to 50% of users</p>

<p>```</p>

<p>Each of these methods have deactivate version for deactivating the feature. You can also just call <code>$rollout.deactivate_all(:chat)</code> to deactivate the feature to all at once.</p>
]]></content>
  </entry>
  
</feed>
