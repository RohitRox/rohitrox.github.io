<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Blog @ RohitRox]]></title>
  <link href="http://rohitrox.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://rohitrox.github.io/"/>
  <updated>2013-08-26T23:12:22+05:45</updated>
  <id>http://rohitrox.github.io/</id>
  <author>
    <name><![CDATA[Rohit Rox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Up and running Ruby on Rails on Ubuntu]]></title>
    <link href="http://rohitrox.github.io/2013/08/26/up-and-running-ruby-on-rails-on-ubuntu/"/>
    <updated>2013-08-26T22:27:00+05:45</updated>
    <id>http://rohitrox.github.io/2013/08/26/up-and-running-ruby-on-rails-on-ubuntu</id>
    <content type="html"><![CDATA[<h3>6 steps for setting ruby on rails development environment in Ubuntu.</h3>

<h3>Step 1: Setting up RVM</h3>

<p>``` bash</p>

<pre><code>$ sudo apt-get update
$ sudo apt-get install curl
$ curl -L https://get.rvm.io | bash -s stable
$ source ~/.rvm/scripts/rvm 
</code></pre>

<p>```</p>

<p>In order to work, RVM has some of its own dependancies that need to be installed. You can see what these are:</p>

<p>``` bash</p>

<pre><code>$ rvm requirements
# In the text that RVM shows you, look for this paragraph.
# Additional Dependencies:
# For ruby:
# apt-get --no-install-recommends install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev  libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev ncurses-dev automake libtool bison subversion pkg-config libffi-dev
# Just follow the instructions to get your system up to date with all of the required dependancies.
$ sudo apt-get --no-install-recommends install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev ncurses-dev automake libtool bison subversion pkg-config libffi-dev
</code></pre>

<p>```
Then</p>

<p>``` bash</p>

<pre><code>$ echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" &gt;&gt; ~/.bash_profile
# or 
$ echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" &gt;&gt; ~/.bashrc
</code></pre>

<p>```</p>

<h3>Step 2: Install ruby</h3>

<p>``` bash</p>

<pre><code>$ rvm install 1.9.3
# after success you can verify your installation by 
$ rvm list
# should output something like 
# rvm rubies
# =* ruby-1.9.3-p362 [ i686 ]
</code></pre>

<p>```</p>

<h3>Step 3: RubyGems</h3>

<p>``` bash</p>

<pre><code>$ rvm rubygems current
</code></pre>

<p>```</p>

<h3>Step 4: Rails</h3>

<p>``` bash</p>

<pre><code># a Javascript runtime, NodeJs
$ sudo add-apt-repository ppa:chris-lea/node.js
$ sudo apt-get update
$ sudo apt-get install nodejs

$ gem install bundler
$ gem install rails
</code></pre>

<p>```</p>

<h3>Step 5: First Rails app</h3>

<p>```</p>

<pre><code>$ rails new my_app
$ cd my_app
$ bundle install
$ rails s
# open browser and visit localhost:3000
# you should see the famous welcome abroad page
</code></pre>

<p>```</p>

<h3>Step 6: Development Extras</h3>

<h4>Sublime Text 2</h4>

<p>``` bash</p>

<pre><code>$ sudo add-apt-repository ppa:webupd8team/sublime-text-2
$ sudo apt-get update
$ sudo apt-get install sublime-text
</code></pre>

<p>```
Install sublime package manager from <a href="http://wbond.net/sublime_packages/package_control/installation">here</a> for other sublime goodies.</p>

<h4>Configure Vim for Rails</h4>

<p>``` bash</p>

<pre><code>$ curl -Lo- https://bit.ly/janus-bootstrap | bash
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Canvas Images and Rails]]></title>
    <link href="http://rohitrox.github.io/2013/07/19/canvas-images-and-rails/"/>
    <updated>2013-07-19T15:15:00+05:45</updated>
    <id>http://rohitrox.github.io/2013/07/19/canvas-images-and-rails</id>
    <content type="html"><![CDATA[<p>With the introduction of Canvas, HTML5 has empower us to draw shapes, graphs, render texts, make gradients and patterns, manipulate images pixels, set an animations, even creating a stunning games!
All this stuffs occur on the client side in the browsers.
So let say you make an app that render some effects in a Canvas element and you want to allow user to take screenshot of the resut or save the result in your server for yourself.</p>

<p>Let&rsquo;s digg how can we do it and save that canvas as an image in ther server using Rails.</p>

<h3>Strategy 1 : Send canvas image as raw dataURL</h3>

<p>The data URI scheme is a URI scheme that provides a way to include data in-line in web pages as if they were external resources. The <code>canvas.toDataURL()</code> method returns the image data of the canvas as Data URI. And the Data URI has the image data Encodes with MIME base64.</p>

<p>Let&rsquo;s see how it works. Copy and run this javascript snippet in your browser console. Somewhere at the bottom of the page you&rsquo;ll see a green circle.</p>

<p>``` javascript</p>

<pre><code>var canvas = document.createElement('canvas');
var context = canvas.getContext('2d');
var centerX = canvas.width / 2;
var centerY = canvas.height / 2;
var radius = 70;

context.beginPath();
context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
context.fillStyle = 'green';
context.fill();
context.lineWidth = 5;
context.strokeStyle = '#003300';
context.stroke();

document.body.appendChild(canvas)
</code></pre>

<p>```
Now lets render that canvas as an image.</p>

<p>``` javascript</p>

<pre><code>var dataURL =  canvas.toDataURL('image/png');
window.location = dataURL;
</code></pre>

<p>```</p>

<!--more-->


<p>As you can see, with that weird long url string something like <code>data:image/png;base64,iVBORw0KGgoA...</code>, it render a png image. That long url is infact data uri which has image data encoded with MIME base64.</p>

<p>The format to be specific is <strong><em> data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt; encoded data &gt; </em></strong>.</p>

<p>Now, if we want to save that image in the server, we can just send that data uri as normal params and at the server, we can use ruby to decode that save that data as image file.</p>

<p>``` ruby</p>

<pre><code>require 'base64'

data = params[:data_uri]
// remove all extras except data
image_data = Base64.decode64(data['data:image/png;base64,'.length .. -1])

File.open("#{Rails.root}/public/uploads/somefilename.png", 'wb') do |f|
  f.write image_data
end
</code></pre>

<p>```</p>

<h3>Strategy 2 : Send It as a Blob object</h3>

<p>This method also use the dataURL but instead of send it as a raw text, we convert it to an image file object and send it.
For this we use the Blob object. Simply it&rsquo;s an object that represent a file-like object, so we create a blob object with the type PNG image, after we append this blob object to a FormData, and finally we send it through the jQuery Ajax Method.</p>

<p>Let&rsquo;s detail a bit what I say above, we already see how we get the dataURL from an object, the dataURL is only a raw text, so we need to decode it to a binary data, we already know that the type of the encoding in the dataURL is Base64, and for decode it using a JavaScript solution we use the predefined atob method, now after decoding it we get a binary data, and we need to convert it to an array where there element is a 8-bit unsigned integer values. Finally we have to put this array in a new Uint8Array object for pass it to our Blob object that represent our file, now let create a function that do this and convert our Canvas to a blob object:</p>

<p>``` javascript</p>

<pre><code>// Convert dataURL to Blob object
function dataURLtoBlob(dataURL) {
  // Decode the dataURL    
  var binary = atob(dataURL.split(',')[1]);
  // Create 8-bit unsigned array
  var array = [];
  for(var i = 0; i &lt; binary.length; i++) {
      array.push(binary.charCodeAt(i));
  }
  // Return our Blob object
  return new Blob([new Uint8Array(array)], {type: 'image/png'});
}
</code></pre>

<p>```</p>

<p>We can now create a new FormData object, put our file on it and send our data using Ajax.</p>

<p>``` javascript</p>

<pre><code>// Get our file
var file= dataURLtoBlob(dataURL);
// Create new form data
var fd = new FormData();
// Append our Canvas image file to the form data
fd.append("image", file);
// And send it
$.ajax({
   url: "/screenshot",
   type: "POST",
   data: fd,
   processData: false,
   contentType: false,
});
</code></pre>

<p>```</p>

<p>At controller:</p>

<p>``` ruby</p>

<pre><code>File.open("#{Rails.root}/public/uploads/somefilename.png", 'wb') do |f|
  f.write(params[:image].read)
end
</code></pre>

<p>```</p>

<p>So, that&rsquo;s it.</p>

<p>This method is more appropriate and faster than the first one.</p>

<p>Those wondering how to mix this with carrierwave and paperclip, here are the links:</p>

<p><a href="http://stackoverflow.com/questions/14900038/rails-carrierwave-iphone-base64-image-upload">Rails carrierwave base-64 encoded image upload</a></p>

<p><a href="https://gist.github.com/WizardOfOgz/1012107">Base64-encoded images with Paperclip</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature flippers with rollout]]></title>
    <link href="http://rohitrox.github.io/2013/03/18/feature-flippers-with-rollout/"/>
    <updated>2013-03-18T12:09:00+05:45</updated>
    <id>http://rohitrox.github.io/2013/03/18/feature-flippers-with-rollout</id>
    <content type="html"><![CDATA[<p>Rollout gem comes handy when we need deploy a beta feature, may be to a selected group of users or some percentage of uses so that few users can try it out before it goes massive.</p>

<p>So lets rollout.</p>

<p>First of all, make sure that you have redis, because rollout uses redis as its backend. Then add <code>gem 'rollout'</code> to gemfile and bundle install.</p>

<p>Now, we need to create a rollout setup file inside initializer.</p>

<p>Let&rsquo;s name it rollout_init.rb which looks like this:</p>

<p>```ruby</p>

<p>  $redis = Redis.new
  $rollout = Rollout.new($redis)
  $rollout.define_group(:admin) do |user|</p>

<pre><code>user.admin?
</code></pre>

<p>  end</p>

<p>```
Documentation suggests to use a global variables. So we create one with a new redis instance.
Then, we create rollout instance passsing that redis instance. We can configure rollout in many ways, here we are defining an admin group by passing a block and checking whether the user belongs to that group or not.
Complete documentation can be found <a href="https://github.com/jamesgolick/rollout">here</a>.</p>

<p>Next, we can now use handy rollout method like for example let&rsquo;s say we need to activate chat feature for admin group only.</p>

<p>``` ruby</p>

<p>  if $rollout.active? :chat, current_user</p>

<pre><code>....
</code></pre>

<p>  end</p>

<p>```</p>

<!--more-->


<p>The <code>$rollout.active?</code> method accepts the name of the feature and the user and returns true or false.</p>

<p>This method is accessible in views as well as in controllers.
That&rsquo;s not all, if you restart your server now and look at the app, you may find out that the feature is unavailable to admin groups also, it is because by default the feature is deactivated to all groups or users. We can make a rake task or an interface for activating the feature to subset of users. Activating code looks like this:</p>

<p>``` ruby</p>

<p>  $rollout.activate_group(:chat, :admin)</p>

<p>```
This will activate the feature ( chat in our case ) for admin group.</p>

<p>Also we can activate the feature to all users or specific user or to some percentage.</p>

<p>``` ruby</p>

<p>  $rollout.activate_group( :chat, :all ) #activate to all, there is all group already by default</p>

<p>  $rollout.activate_user( :chat, User.find_by_email(&ldquo;<a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x61;&#x64;&#109;&#x69;&#110;&#x40;&#x6d;&#121;&#97;&#x70;&#112;&#46;&#x63;&#111;&#x6d;">&#x61;&#100;&#x6d;&#105;&#x6e;&#x40;&#109;&#x79;&#97;&#x70;&#112;&#x2e;&#x63;&#111;&#x6d;</a>&rdquo;) ) #activate to specific user</p>

<p>  $rollout.activate_percantage( :chat, 50 ) #activate to 50% of users</p>

<p>```</p>

<p>Each of these methods have deactivate version for deactivating the feature. You can also just call <code>$rollout.deactivate_all(:chat)</code> to deactivate the feature to all at once.</p>
]]></content>
  </entry>
  
</feed>
