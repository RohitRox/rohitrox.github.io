<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Blog @ RohitRox]]></title>
  <link href="http://rohitrox.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://rohitrox.github.io/"/>
  <updated>2015-11-16T11:06:40-05:00</updated>
  <id>http://rohitrox.github.io/</id>
  <author>
    <name><![CDATA[Rohit Rox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails api backed with jwt]]></title>
    <link href="http://rohitrox.github.io/2015/06/23/rails-api-backed-with-jwt/"/>
    <updated>2015-06-23T21:23:00-04:00</updated>
    <id>http://rohitrox.github.io/2015/06/23/rails-api-backed-with-jwt</id>
    <content type="html"><![CDATA[<p>Stand-alone client side applications, REST, API, JSON Web Token is all over the web. Last week I sat with one of my friend (Front-End Developer) to hack an Javascript MVC app with Rails-Api.</p>

<p>An awesome api, in the minds have following characterstics:</p>

<ul>
<li>Excellent docs with success and failure sample response</li>
<li>A standard authorization mechanism</li>
<li>Consistent response body and codes</li>
</ul>


<p>However, being an api developer in addition to that, I would like to have an automated tool that would help me to make sure that docs are always upto date with the api and I would like to use the latest and adopted authentication mechanism.</p>

<p>I would like to share my story of api development with Rails-api, Rspec, Rspec-api-documentation and JSON Web Token(JWT).</p>

<p>This is not a long tutorial about getting started with rails-devise-jwt, there is already lots of articles about what and why JWT and using JWT with ruby and rails. This is a blueprint of an end-to-end solution I adopted for development of an api.</p>

<p>The sample app is available <a href="https://github.com/RohitRox/Rails-API-and-JWT">here at github</a>.</p>

<p>The <a href="https://github.com/RohitRox/Rails-API-and-JWT/commits/master">commit</a> in the speaks itself for steps that were done.</p>

<!-- more -->


<p>The first seven commits are all about setting up an rails-api app, getting required gems, creating CRUD resource, devise user installation. I used jbuilder for building json responses and kaminari for pagination.</p>

<p>I used Rspec and Rspec-api-documentation for testing. Setting up Rspec-api-documentation is quite straight forward and I didn&rsquo;t feel any difficulty in folowing their readme. I really like this gem, works very well, the dsl it provides is decent, the page it generates looks good and it can generate in various formats. The strategy I took, was, to have controller and model specs as it would be, but put the api-documentation specs in a special folder &lsquo;specs/acceptance&rsquo;. The api-documentation specs would assert only for response codes and have examples for requests with valid as well invalid params. This way, my usual controller and model specs make sure the api are up and good and api-documentation will make sure that the docs have the up-to-date params, request body and response body specifications.</p>

<p>To make the response body consistent, I have followed following schema:</p>

<p>```json</p>

<pre><code>// POST /api/posts
{
  "data": {
    "id": 1,
    "title": "My Title",
    "content": "Some long long awesome content."
  },
  "response": {
    "code": 201
  },
  "links": {
    "self": "http://example.org/api/posts/1"
  }
}
</code></pre>

<p>```</p>

<p>```json
  // GET /api/posts
  {</p>

<pre><code>"data": [
  {
    "id": 2,
    "title": "Vel sit in molestias iste voluptas nam ad.",
    "content": "Facilis rem quia quas repudiandae non. Dignissimos dolores rerum aperiam inventore non doloremque laborum. Ex aut autem deserunt molestiae quae repellendus consequatur."
  },
  {
    "id": 1,
    "title": "Aliquid atque distinctio ab quaerat qui adipisci.",
    "content": "Facilis rem quia quas repudiandae non. Dignissimos dolores rerum aperiam inventore non doloremque laborum. Ex aut autem deserunt molestiae quae repellendus consequatur."
  }
],
"meta": {
  "current_page": 1,
  "next_page": null,
  "prev_page": null,
  "total_pages": 1,
  "total_count": 2,
  "sort": "created_at",
  "order": "desc"
},
"response": {
  "code": 200
}
</code></pre>

<p>  }</p>

<p>```</p>

<p>I would not say this is the standard json response structure for a REST Api, but my front-end developer friend found it pretty neat.</p>

<p>Finally, devise, I do not have any specific reason why I was using devise, I mean the solution I was doing could be done without devise but somewhere in the future a couple of devise modules may be useful. I have a <a href="https://github.com/RohitRox/Rails-API-and-JWT/commit/10a17cb0c5a8e24015a5f2f77607b0e390f6acca">commit</a> for using devise and overiding devise controller for signing-in and signing-up users. At that time, I looked at different approaches and decided to go with that. Basically we hijack devise controller actions for signing-up and signing-in, this is necessary because later we need to generate and inject auth-token there.</p>

<p>Next step is to use &lsquo;jwt&rsquo; gem to generate auth-tokens and decode the tokens to extract claims and verify its authenticty.
This <a href="http://nebulab.it/blog/authentication-with-rails-jwt-and-react">article</a> describes really well. The steps are pretty straight forward, we generate JSON Web token and send them in response at sign-in or sign-up actions, client requests resource with token set in Authorization headers, we decode the token and extract the information we had set. The commits <a href="https://github.com/RohitRox/Rails-API-and-JWT/commit/548a1268c943a8895d3f67ad33358150e45449ec">here</a> and <a href="https://github.com/RohitRox/Rails-API-and-JWT/commit/a7714cf68f62e4b0342b155bc3308ca20fa2ae2b">this</a> is where I have integrated the JWT authentication mechanisms.</p>

<p>This is what the code looks like:</p>

<p>```ruby
  #lib/json_web_token.rb
  require &lsquo;jwt&rsquo;</p>

<p>  class JsonWebToken</p>

<pre><code>def self.encode(payload, expiration = 24.hours.from_now)
  payload = payload.dup
  payload['exp'] = expiration.to_i
  JWT.encode(payload, Rails.application.secrets.json_web_token_secret)
end

def self.decode(token)
  JWT.decode(token, Rails.application.secrets.json_web_token_secret)
end
</code></pre>

<p>  end</p>

<p>```</p>

<p>```ruby
  #app/controllers/api/base_controller.rb
  class Api::BaseController &lt; ApplicationController
  include ActionController::ImplicitRender
  respond_to :json</p>

<p>  before_filter :authenticate_user_from_token!</p>

<p>  protected</p>

<pre><code>def authenticate_user_from_token!
  if claims and user = User.find_by(email: claims[0]['user'])
    @current_user = user
  else
    return render_unauthorized errors: { unauthorized: ["You are not authorized perform this action."] }
  end
end

def claims
  auth_header = request.headers['Authorization'] and
    token = auth_header.split(' ').last and
    ::JsonWebToken.decode(token)
rescue
  nil
end

def jwt_token user
  JsonWebToken.encode('user' =&gt; user.email)
end

def render_unauthorized(payload)
  render json: payload.merge(response: { code: 401 })
end
</code></pre>

<p>  end</p>

<p>```</p>

<p>I have the sample app running at heroku and docs at <a href="https://rails-api-jwt.herokuapp.com/api/docs/">https://rails-api-jwt.herokuapp.com/api/docs/</a>.</p>

<p>I have drawn a lot of inspiration and some code from following blog posts to create this.</p>

<ul>
<li><a href="http://nebulab.it/blog/authentication-with-rails-jwt-and-react">http://nebulab.it/blog/authentication-with-rails-jwt-and-react</a></li>
<li><a href="http://adamalbrecht.com/2014/12/04/add-json-web-token-authentication-to-your-angular-rails-app/">http://adamalbrecht.com/2014/12/04/add-json-web-token-authentication-to-your-angular-rails-app/</a></li>
<li><a href="http://blog.moove-it.com/token-based-authentication-json-web-tokenjwt/">http://blog.moove-it.com/token-based-authentication-json-web-tokenjwt/</a></li>
<li><a href="http://zacstewart.com/2015/05/14/using-json-web-tokens-to-authenticate-javascript-front-ends-on-rails.html">http://zacstewart.com/2015/05/14/using-json-web-tokens-to-authenticate-javascript-front-ends-on-rails.html</a></li>
</ul>


<p>Note that there is no error handling when decoding the token in the sample app. These as well as other algorithm information are well described in the <a href="https://github.com/progrium/ruby-jwt">&lsquo;ruby-jwt&rsquo; gem github page</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Cli and Rails And Beyond]]></title>
    <link href="http://rohitrox.github.io/2014/12/06/embercli-and-rails-and-beyond/"/>
    <updated>2014-12-06T16:44:00-05:00</updated>
    <id>http://rohitrox.github.io/2014/12/06/embercli-and-rails-and-beyond</id>
    <content type="html"><![CDATA[<h3>Ember Cli and Rails Setup</h3>

<p>Rails setup is pretty staright forward with <code>rails new ..</code> and new ember cli app with <code>ember new ..</code>  but with following folder configuration</p>

<p><code>
  | embercli-rails-app
  |-- rails  
  |-- ember
</code>
Inside of main project folder we&rsquo;ll have a folder which will contain the rails code and another folder which will contain ember code only.</p>

<p>We would like to have coffeescript.</p>

<p>For coffeescript</p>

<p><code>
  $ npm install --save-dev ember-cli-coffeescript
</code></p>

<p>and renaming .js files to .coffee and correcting the js syntax to coffee will do the trick.</p>

<p>Make sure that ember app is all well by using <code>ember server</code> and visiting <a href="http://localhost:4200.">http://localhost:4200.</a></p>

<p>Before proceeding, it would be nice to have some tests.</p>

<p>Lets create a new test at &lsquo;ember/tests/integration/home-page-test.coffee&rsquo;.</p>

<p>``` coffeescript</p>

<p>  <code>import Ember from 'ember'</code>
  <code>import startApp from 'cli-app/tests/helpers/start-app'</code>
  <code>import Ember from 'ember'</code></p>

<p>  App = null</p>

<p>  module &lsquo;Integration &ndash; Home Page&rsquo;,</p>

<pre><code>setup: -&gt;
  App = startApp()
,
teardown: -&gt;
  Ember.run(App, 'destroy')
</code></pre>

<p>  test &lsquo;Should have Welcome test&rsquo;, &ndash;></p>

<pre><code>visit('/').then -&gt;
  equal(find('h2#title').text(), 'Welcome to Ember.js');
</code></pre>

<p>```
Visit <a href="http://localhost:4200/tests">http://localhost:4200/tests</a> to run the tests.</p>

<!-- more -->


<h3>Rails Api</h3>

<p>Let&rsquo;s quickly build an api that can be consumed by our ember app. We are skipping out the tests.</p>

<p><code>
  rails g model post title:string body:text
  rake db:create db:migrate db:seed
  rails g serializer post
</code>
We are going to make our api under api namespace so routes and controllers are as follows:</p>

<p>``` ruby
  // config/routes.rb
  namespace :api do</p>

<pre><code>resources :posts
</code></pre>

<p>  end
```</p>

<p>``` ruby
  // app/controllers/api/posts_controller.rb
  class Api::PostsController &lt; ApplicationController</p>

<pre><code>def index
  render json: Post.all
end

def show
  render json: Post.find(params[:id])
end
</code></pre>

<p>  end
<code>``
Boot rails server and make sure api is working using curl command</code>curl <a href="http://0.0.0.0:3000/api/posts">http://0.0.0.0:3000/api/posts</a>` and see if it outputs json data.</p>

<h3>Ember Data and stuffs</h3>

<p>First, create ember model for Post model.</p>

<p><code>
  $ ember generate model post title:string body:string
</code></p>

<p>Then setup routes and templates.</p>

<p>``` coffeescript
  # app/router.coffee
  Router.map &ndash;></p>

<pre><code>@resource 'posts'
</code></pre>

<p><code>

</code> html
  # app/templates/posts.hbs
  <h3>Listing All Posts:</h3>
  <ul>
  {{ #each }}</p>

<pre><code>&lt;li&gt;{{ title }}&lt;/li&gt;
</code></pre>

<p>  {{ /each }}
  </ul>
```

Finally, let&rsquo;s setup the adapter.</p>

<p><code>`` coffeescript
  # ember/app/adapters/application.coffee
 </code>import DS from &lsquo;ember-data&rsquo;`</p>

<p>  ApplicationAdapter = DS.ActiveModelAdapter.extend</p>

<pre><code>namespace: "api"
</code></pre>

<p>  <code>export default ApplicationAdapter</code>
```</p>

<p>Now let&rsquo;s fire the ember server and visit <a href="http://localhost:4200/posts.">http://localhost:4200/posts.</a>
Nothing happens! In console we can see that there was request was made on url <a href="http://localhost:4200/api/posts.">http://localhost:4200/api/posts.</a>
We need a way to redirect this resource to rails app.</p>

<p>This can be fixed by one line using ember server with proxy enabled.
<code>
  $ ember server --proxy http://localhost:3000
</code></p>

<h3>More Tests</h3>

<p>Let&rsquo;s try to test this new posts page feature. In test we cannot hit rails server to get posts so we will use a tool called <a href="https://github.com/trek/pretender">Pretender</a> to mock the request-response.</p>

<p><code>
  $ npm install --save-dev ember-cli-pretender
  $ ember generate ember-cli-pretender
</code></p>

<p>Our test setup and test would be something like below:</p>

<p><code>`` coffeescript
  # tests/integration/posts-page-test.coffee
 </code>import Ember from &lsquo;ember&rsquo;<code>
 </code>import startApp from &lsquo;cli-app/tests/helpers/start-app&rsquo;<code>
 </code>import Ember from &lsquo;ember&rsquo;<code>
 </code>import Pretender from &lsquo;pretender&rsquo;`</p>

<p>  App = null</p>

<p>  module &lsquo;Integration &ndash; Posts Page&rsquo;,</p>

<pre><code>setup: -&gt;
  App = startApp()
  posts = [
    {
      id: 1,
      title: 'Posts 1'
    },
    {
      id: 2,
      title: 'Posts 2'
    }
  ]
  # pretender for faking ajax request
  server = new Pretender -&gt;
    @get '/api/posts', (request) -&gt;
      [200, {"Content-Type": "application/json"}, JSON.stringify({posts: posts})]
,
teardown: -&gt;
  Ember.run(App, 'destroy')
</code></pre>

<p>  test &lsquo;Should display posts&rsquo;, &ndash;></p>

<pre><code>visit('/').then -&gt;
  click('a').then -&gt;
    equal(find('h3').text(), 'Listing All Posts:');
    equal(find('li:contains("Posts 1")').length, 1);
    equal(find('li:contains("Posts 2")').length, 1);
</code></pre>

<p>```
Visit <a href="http://localhost:4200/tests">http://localhost:4200/tests</a> to run the tests.</p>

<h3>Integration and Deployment</h3>

<p>We would like to compile and move the ember-cli produced css and js files to rails in production environment. This little script helps us to automate this task:</p>

<p>``` bash</p>

<p>  #!/bin/bash
  # Based on <a href="https://github.com/knomedia/ember-cli-rails/blob/master/build.sh">https://github.com/knomedia/ember-cli-rails/blob/master/build.sh</a></p>

<p>  function printMessage {</p>

<pre><code>color=$(tput setaf $1)
message=$2
reset=$(tput sgr0)
echo -e "${color}${message}${reset}"
</code></pre>

<p>  }</p>

<p>  function boldMessage {</p>

<pre><code>color=$(tput setaf $1)
message=$2
reset=$(tput sgr0)
echo -e "${color}*************************************${reset}"
echo -e "${color}${message}${reset}"
echo -e "${color}*************************************${reset}"
</code></pre>

<p>  }</p>

<p>  cd cli-app
  boldMessage 4 &ldquo;Building Ember app&rdquo;</p>

<p>  ember build &mdash;environment production
  cd ../rails/</p>

<p>  rm -rf public/ember-assets</p>

<p>  printMessage 4 &ldquo;Copying ember build files to rails&rdquo;
  cp -r ../cli-app/dist/ public/</p>

<p>  printMessage 4 &ldquo;Swaping assets dir for ember-assets&rdquo;
  mv public/assets public/ember-assets</p>

<p>  printMessage 4 &ldquo;Replacing references s/assets/ember-assets/ in public/index.html&rdquo;
  sed -i .bck s/assets/ember-assets/ public/index.html</p>

<p>  printMessage 4 &ldquo;inserting csrf_meta_tags in head&rdquo;
  sed -i .bck &rsquo;s/&lt;\/head>/&lt;%= csrf_meta_tags %>&amp;/&lsquo; public/index.html</p>

<p>  printMessage 4 &ldquo;inserting yield in body&rdquo;
  sed -i .bck &rsquo;s/<body>/&amp;&lt;%= yield %>/&lsquo; public/index.html</p>

<p>  printMessage 4 &ldquo;Replacing application.html.erb with index.html&rdquo;
  mv public/index.html app/views/layouts/application.html.erb</p>

<p>  printMessage 4 &ldquo;Cleaning Up&rdquo;
  rm -rf public_bk/
  rm public/index.html.bck</p>

<p>  boldMessage 4 &ldquo;Done&rdquo;
```</p>

<p>Now, we can shutdown ember server and visit localhost:3000, we can still see our ember app there.</p>

<p>To deploy our app we need to deploy our rails app only. We can put out both frontend and backend in single repo or in different repo. I have put both in a single <a href="https://github.com/RohitRox/embercli-rails">repo</a>. Do <code>config.serve_static_assets = true</code> in production.rb We can deploy like any other rails app. I have deployed this app to <a href="https://embercli-rails.herokuapp.com/posts">heroku</a>. One gotcha is that heroku expects the app directory structure at the root of the repository. So to deploy we will have to push differently:
<code>
  $ git subtree push --prefix rails heroku master
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Single Table Inheritance in Mongoid]]></title>
    <link href="http://rohitrox.github.io/2013/08/30/single-table-inheritance-in-mongoid/"/>
    <updated>2013-08-30T14:04:00-04:00</updated>
    <id>http://rohitrox.github.io/2013/08/30/single-table-inheritance-in-mongoid</id>
    <content type="html"><![CDATA[<p>Single table inheritance is a software pattern described by Martin Fowler. STI is basically an idea of using a single table(colection in case of mongo) to reflect multiple models that inherit from a base model.</p>

<p>We use STI pattern when we are dealing with classes that have same attributes and behaviour. Rather than duplicate the same code over and over, STI helps us to use a common base model and write specific behaviours in its inherited class while keeeping data on a same table.</p>

<p>Mongoid supports inheritance in both root and embedded documents. In
scenarios where documents are inherited from their fields, relations, validations and scopes get copied down into their child documents, but not vice-versa.</p>

<p>A very simple example:</p>

<p>``` ruby</p>

<pre><code>class Employee
  include Mongoid::Document
  field :name, type: String
  field :employee_code, type: Integer
end

class FullTimeEmployee &lt; Employee
  field status, type: String, default: "Temporary"
end

class InternEmployee &lt; Employee
  field intern_period, type: Integer
end
</code></pre>

<p>```</p>

<!-- more -->


<p>In the above example, both FullTimeEmployee and InternEmployee will be saved in the Employee collection. An additional attribute _type is automatically stored in order to make sure when loaded from the database the correct document is returned.</p>

<p>Following behaviour can be seen, much similar to Single Table Inheritance in ActiveRecord.</p>

<p>``` ruby</p>

<p>  emp1 = Employee.new
  emp2 = FullTimeEmployee.new
  emp3 = InternEmployee.new</p>

<p>  Employee.count
  #=> 3
  FullTimeEmployee.count
  #=> 1
  InternEmployee.count
  #=> 1
  emp1.<em>type
  #=> &ldquo;Employee&rdquo;
  emp2.</em>type
  #=> &ldquo;FullTimeEmployee&rdquo;
  emp3._type
  #=> &ldquo;InternEmployee&rdquo;</p>

<p>  Employee.where(name: &ldquo;&hellip;&rdquo;)
  #=> Returns Employee documents and subclasses
  FullTimeEmployee.where(name: &ldquo;&hellip;&rdquo;)
  #=> returns only FullTimeEmployee documents</p>

<p>```</p>

<p>An advance example:</p>

<p>``` ruby</p>

<pre><code>class Canvas
  include Mongoid::Document
  field :name, type: String
  embeds_many :shapes
end

class Browser &lt; Canvas
  field :version, type: Integer
  scope :recent, where(:version.gt =&gt; 3)
end

class Firefox &lt; Browser
end

class Shape
  include Mongoid::Document
  field :x, type: Integer
  field :y, type: Integer
  embedded_in :canvas
end

class Circle &lt; Shape
  field :radius, type: Float
end

class Rectangle &lt; Shape
  field :width, type: Float
  field :height, type: Float
end
</code></pre>

<p>```</p>

<p>Canvas, Browser and Firefox will all save in the canvases collection.This also holds true for the embedded documents Circle, Rectangle, and Shape.</p>

<p>To query for subclasses within an embedded collection you need to leverage the <em>type attribute in each subclassed object. Canvas and Shape documents, would not have it, but Browser, Firefox, Circle, and Rectangle would. Keep in mind that </em>type is a string that stores the name of the document&rsquo;s class, and as such can only be used to query for a specific subclass, and not anything it is a subclass of.</p>

<p>If, for example, Rectangle was a subclass of Parallelogram which was in turn a subclass of Shape, you could search the Canvas&rsquo;s shapes collection for objects with a _type of &ldquo;Parallelogram&rdquo; but it would never return a Rectangle object, and vice-versa.</p>

<p>``` ruby</p>

<p>  # Returns all the Rectangle shapes in a previously found Canvas
  my_canvas.shapes.where(_type: &ldquo;Rectangle&rdquo;)</p>

<p>  # Returns no entries (see above)
  my_canvas.shapes.where(_type: &ldquo;Shape&rdquo;)</p>

<p>  # Returns all the Canvasas that have Circles
  Canvas.where(&ldquo;shapes._type&rdquo;=>&ldquo;Circle&rdquo;)</p>

<p>  # Returns no entries (see above)
  Canvas.where(&ldquo;shapes._type'=>"Shape&rdquo;)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Up and running Ruby on Rails on Ubuntu]]></title>
    <link href="http://rohitrox.github.io/2013/08/26/up-and-running-ruby-on-rails-on-ubuntu/"/>
    <updated>2013-08-26T22:27:00-04:00</updated>
    <id>http://rohitrox.github.io/2013/08/26/up-and-running-ruby-on-rails-on-ubuntu</id>
    <content type="html"><![CDATA[<h3>6 steps for setting ruby on rails development environment in Ubuntu.</h3>

<h3>Step 1: Setting up RVM</h3>

<p>``` bash</p>

<pre><code>$ sudo apt-get update
$ sudo apt-get install curl
$ curl -L https://get.rvm.io | bash -s stable
$ source ~/.rvm/scripts/rvm 
</code></pre>

<p>```</p>

<p>In order to work, RVM has some of its own dependancies that need to be installed. You can see what these are:</p>

<p>``` bash</p>

<pre><code>$ rvm requirements
# In the text that RVM shows you, look for this paragraph.
# Additional Dependencies:
# For ruby:
# apt-get --no-install-recommends install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev  libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev ncurses-dev automake libtool bison subversion pkg-config libffi-dev
# Just follow the instructions to get your system up to date with all of the required dependancies.
$ sudo apt-get --no-install-recommends install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev ncurses-dev automake libtool bison subversion pkg-config libffi-dev
</code></pre>

<p>```
Then</p>

<p>``` bash</p>

<pre><code>$ echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" &gt;&gt; ~/.bash_profile
# or 
$ echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" &gt;&gt; ~/.bashrc
</code></pre>

<p>```</p>

<h3>Step 2: Install ruby</h3>

<p>``` bash</p>

<pre><code>$ rvm install 1.9.3
# after success you can verify your installation by 
$ rvm list
# should output something like 
# rvm rubies
# =* ruby-1.9.3-p362 [ i686 ]
</code></pre>

<p>```</p>

<h3>Step 3: RubyGems</h3>

<p>``` bash</p>

<pre><code>$ rvm rubygems current
</code></pre>

<p>```</p>

<h3>Step 4: Rails</h3>

<p>``` bash</p>

<pre><code># a Javascript runtime, NodeJs
$ sudo add-apt-repository ppa:chris-lea/node.js
$ sudo apt-get update
$ sudo apt-get install nodejs

$ gem install bundler
$ gem install rails
</code></pre>

<p>```</p>

<h3>Step 5: First Rails app</h3>

<p>```</p>

<pre><code>$ rails new my_app
$ cd my_app
$ bundle install
$ rails s
# open browser and visit localhost:3000
# you should see the famous welcome abroad page
</code></pre>

<p>```</p>

<h3>Step 6: Development Extras</h3>

<h4>Sublime Text 2</h4>

<p>``` bash</p>

<pre><code>$ sudo add-apt-repository ppa:webupd8team/sublime-text-2
$ sudo apt-get update
$ sudo apt-get install sublime-text
</code></pre>

<p>```
Install sublime package manager from <a href="http://wbond.net/sublime_packages/package_control/installation">here</a> for other sublime goodies.</p>

<h4>Configure Vim for Rails</h4>

<p>``` bash</p>

<pre><code>$ curl -Lo- https://bit.ly/janus-bootstrap | bash
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Canvas Images and Rails]]></title>
    <link href="http://rohitrox.github.io/2013/07/19/canvas-images-and-rails/"/>
    <updated>2013-07-19T15:15:00-04:00</updated>
    <id>http://rohitrox.github.io/2013/07/19/canvas-images-and-rails</id>
    <content type="html"><![CDATA[<p>With the introduction of Canvas, HTML5 has empower us to draw shapes, graphs, render texts, make gradients and patterns, manipulate images pixels, set an animations, even creating a stunning games!
All this stuffs occur on the client side in the browsers.
So let say you make an app that render some effects in a Canvas element and you want to allow user to take screenshot of the resut or save the result in your server for yourself.</p>

<p>Let&rsquo;s digg how can we do it and save that canvas as an image in ther server using Rails.</p>

<h3>Strategy 1 : Send canvas image as raw dataURL</h3>

<p>The data URI scheme is a URI scheme that provides a way to include data in-line in web pages as if they were external resources. The <code>canvas.toDataURL()</code> method returns the image data of the canvas as Data URI. And the Data URI has the image data Encodes with MIME base64.</p>

<p>Let&rsquo;s see how it works. Copy and run this javascript snippet in your browser console. Somewhere at the bottom of the page you&rsquo;ll see a green circle.</p>

<p>``` javascript</p>

<pre><code>var canvas = document.createElement('canvas');
var context = canvas.getContext('2d');
var centerX = canvas.width / 2;
var centerY = canvas.height / 2;
var radius = 70;

context.beginPath();
context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
context.fillStyle = 'green';
context.fill();
context.lineWidth = 5;
context.strokeStyle = '#003300';
context.stroke();

document.body.appendChild(canvas)
</code></pre>

<p>```
Now lets render that canvas as an image.</p>

<p>``` javascript</p>

<pre><code>var dataURL =  canvas.toDataURL('image/png');
window.location = dataURL;
</code></pre>

<p>```</p>

<!--more-->


<p>As you can see, with that weird long url string something like <code>data:image/png;base64,iVBORw0KGgoA...</code>, it render a png image. That long url is infact data uri which has image data encoded with MIME base64.</p>

<p>The format to be specific is <strong><em> data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt; encoded data &gt; </em></strong>.</p>

<p>Now, if we want to save that image in the server, we can just send that data uri as normal params and at the server, we can use ruby to decode that save that data as image file.</p>

<p>``` ruby</p>

<pre><code>require 'base64'

data = params[:data_uri]
// remove all extras except data
image_data = Base64.decode64(data['data:image/png;base64,'.length .. -1])

File.open("#{Rails.root}/public/uploads/somefilename.png", 'wb') do |f|
  f.write image_data
end
</code></pre>

<p>```</p>

<h3>Strategy 2 : Send It as a Blob object</h3>

<p>This method also use the dataURL but instead of send it as a raw text, we convert it to an image file object and send it.
For this we use the Blob object. Simply it&rsquo;s an object that represent a file-like object, so we create a blob object with the type PNG image, after we append this blob object to a FormData, and finally we send it through the jQuery Ajax Method.</p>

<p>Let&rsquo;s detail a bit what I say above, we already see how we get the dataURL from an object, the dataURL is only a raw text, so we need to decode it to a binary data, we already know that the type of the encoding in the dataURL is Base64, and for decode it using a JavaScript solution we use the predefined atob method, now after decoding it we get a binary data, and we need to convert it to an array where there element is a 8-bit unsigned integer values. Finally we have to put this array in a new Uint8Array object for pass it to our Blob object that represent our file, now let create a function that do this and convert our Canvas to a blob object:</p>

<p>``` javascript</p>

<pre><code>// Convert dataURL to Blob object
function dataURLtoBlob(dataURL) {
  // Decode the dataURL    
  var binary = atob(dataURL.split(',')[1]);
  // Create 8-bit unsigned array
  var array = [];
  for(var i = 0; i &lt; binary.length; i++) {
      array.push(binary.charCodeAt(i));
  }
  // Return our Blob object
  return new Blob([new Uint8Array(array)], {type: 'image/png'});
}
</code></pre>

<p>```</p>

<p>We can now create a new FormData object, put our file on it and send our data using Ajax.</p>

<p>``` javascript</p>

<pre><code>// Get our file
var file= dataURLtoBlob(dataURL);
// Create new form data
var fd = new FormData();
// Append our Canvas image file to the form data
fd.append("image", file);
// And send it
$.ajax({
   url: "/screenshot",
   type: "POST",
   data: fd,
   processData: false,
   contentType: false,
});
</code></pre>

<p>```</p>

<p>At controller:</p>

<p>``` ruby</p>

<pre><code>File.open("#{Rails.root}/public/uploads/somefilename.png", 'wb') do |f|
  f.write(params[:image].read)
end
</code></pre>

<p>```</p>

<p>So, that&rsquo;s it.</p>

<p>This method is more appropriate and faster than the first one.</p>

<p>Those wondering how to mix this with carrierwave and paperclip, here are the links:</p>

<p><a href="http://stackoverflow.com/questions/14900038/rails-carrierwave-iphone-base64-image-upload">Rails carrierwave base-64 encoded image upload</a></p>

<p><a href="https://gist.github.com/WizardOfOgz/1012107">Base64-encoded images with Paperclip</a></p>
]]></content>
  </entry>
  
</feed>
