<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Blog @ RohitRox]]></title>
  <link href="http://rohitrox.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://rohitrox.github.io/"/>
  <updated>2014-12-07T15:17:08-05:00</updated>
  <id>http://rohitrox.github.io/</id>
  <author>
    <name><![CDATA[Rohit Rox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ember Cli and Rails And Beyond]]></title>
    <link href="http://rohitrox.github.io/2014/12/06/embercli-and-rails-and-beyond/"/>
    <updated>2014-12-06T16:44:00-05:00</updated>
    <id>http://rohitrox.github.io/2014/12/06/embercli-and-rails-and-beyond</id>
    <content type="html"><![CDATA[<h3>Ember Cli and Rails Setup</h3>

<p>Rails setup is pretty staright forward with <code>rails new ..</code> and new ember cli app with <code>ember new ..</code>  but with following folder configuration</p>

<p><code>
  | embercli-rails-app
  |-- rails  
  |-- ember
</code>
Inside of main project folder we&rsquo;ll have a folder which will contain the rails code and another folder which will contain ember code only.</p>

<p>We would like to have coffeescript.</p>

<p>For coffeescript</p>

<p><code>
  $ npm install --save-dev ember-cli-coffeescript
</code></p>

<p>and renaming .js files to .coffee and correcting the js syntax to coffee will do the trick.</p>

<p>Make sure that ember app is all well by using <code>ember server</code> and visiting <a href="http://localhost:4200.">http://localhost:4200.</a></p>

<p>Before proceeding, it would be nice to have some tests.</p>

<p>Lets create a new test at &lsquo;ember/tests/integration/home-page-test.coffee&rsquo;.</p>

<p>``` coffeescript</p>

<p>  <code>import Ember from 'ember'</code>
  <code>import startApp from 'cli-app/tests/helpers/start-app'</code>
  <code>import Ember from 'ember'</code></p>

<p>  App = null</p>

<p>  module &lsquo;Integration &ndash; Home Page&rsquo;,</p>

<pre><code>setup: -&gt;
  App = startApp()
,
teardown: -&gt;
  Ember.run(App, 'destroy')
</code></pre>

<p>  test &lsquo;Should have Welcome test&rsquo;, &ndash;></p>

<pre><code>visit('/').then -&gt;
  equal(find('h2#title').text(), 'Welcome to Ember.js');
</code></pre>

<p>```
Visit <a href="http://localhost:4200/tests">http://localhost:4200/tests</a> to run the tests.</p>

<!-- more -->


<h3>Rails Api</h3>

<p>Let&rsquo;s quickly build an api that can be consumed by our ember app. We are skipping out the tests.</p>

<p><code>
  rails g model post title:string body:text
  rake db:create db:migrate db:seed
  rails g serializer post
</code>
We are going to make our api under api namespace so routes and controllers are as follows:</p>

<p>``` ruby
  // config/routes.rb
  namespace :api do</p>

<pre><code>resources :posts
</code></pre>

<p>  end
```</p>

<p>``` ruby
  // app/controllers/api/posts_controller.rb
  class Api::PostsController &lt; ApplicationController</p>

<pre><code>def index
  render json: Post.all
end

def show
  render json: Post.find(params[:id])
end
</code></pre>

<p>  end
<code>``
Boot rails server and make sure api is working using curl command</code>curl <a href="http://0.0.0.0:3000/api/posts">http://0.0.0.0:3000/api/posts</a>` and see if it outputs json data.</p>

<h3>Ember Data and stuffs</h3>

<p>First, create ember model for Post model.</p>

<p><code>
  $ ember generate model post title:string body:string
</code></p>

<p>Then setup routes and templates.</p>

<p>``` coffeescript
  # app/router.coffee
  Router.map &ndash;></p>

<pre><code>@resource 'posts'
</code></pre>

<p><code>

</code> html
  # app/templates/posts.hbs
  <h3>Listing All Posts:</h3>
  <ul>
  {{ #each }}</p>

<pre><code>&lt;li&gt;{{ title }}&lt;/li&gt;
</code></pre>

<p>  {{ /each }}
  </ul>
```

Finally, let&rsquo;s setup the adapter.</p>

<p><code>`` coffeescript
  # ember/app/adapters/application.coffee
 </code>import DS from &lsquo;ember-data&rsquo;`</p>

<p>  ApplicationAdapter = DS.ActiveModelAdapter.extend</p>

<pre><code>namespace: "api"
</code></pre>

<p>  <code>export default ApplicationAdapter</code>
```</p>

<p>Now let&rsquo;s fire the ember server and visit <a href="http://localhost:4200/posts.">http://localhost:4200/posts.</a>
Nothing happens! In console we can see that there was request was made on url <a href="http://localhost:4200/api/posts.">http://localhost:4200/api/posts.</a>
We need a way to redirect this resource to rails app.</p>

<p>This can be fixed by one line using ember server with proxy enabled.
<code>
  $ ember server --proxy http://localhost:3000
</code></p>

<h3>More Tests</h3>

<p>Let&rsquo;s try to test this new posts page feature. In test we cannot hit rails server to get posts so we will use a tool called <a href="https://github.com/trek/pretender">Pretender</a> to mock the request-response.</p>

<p><code>
  $ npm install --save-dev ember-cli-pretender
  $ ember generate ember-cli-pretender
</code></p>

<p>Our test setup and test would be something like below:</p>

<p><code>`` coffeescript
  # tests/integration/posts-page-test.coffee
 </code>import Ember from &lsquo;ember&rsquo;<code>
 </code>import startApp from &lsquo;cli-app/tests/helpers/start-app&rsquo;<code>
 </code>import Ember from &lsquo;ember&rsquo;<code>
 </code>import Pretender from &lsquo;pretender&rsquo;`</p>

<p>  App = null</p>

<p>  module &lsquo;Integration &ndash; Posts Page&rsquo;,</p>

<pre><code>setup: -&gt;
  App = startApp()
  posts = [
    {
      id: 1,
      title: 'Posts 1'
    },
    {
      id: 2,
      title: 'Posts 2'
    }
  ]
  # pretender for faking ajax request
  server = new Pretender -&gt;
    @get '/api/posts', (request) -&gt;
      [200, {"Content-Type": "application/json"}, JSON.stringify({posts: posts})]
,
teardown: -&gt;
  Ember.run(App, 'destroy')
</code></pre>

<p>  test &lsquo;Should display posts&rsquo;, &ndash;></p>

<pre><code>visit('/').then -&gt;
  click('a').then -&gt;
    equal(find('h3').text(), 'Listing All Posts:');
    equal(find('li:contains("Posts 1")').length, 1);
    equal(find('li:contains("Posts 2")').length, 1);
</code></pre>

<p>```
Visit <a href="http://localhost:4200/tests">http://localhost:4200/tests</a> to run the tests.</p>

<h3>Integration and Deployment</h3>

<p>We would like to compile and move the ember-cli produced css and js files to rails in production environment. This little script helps us to automate this task:</p>

<p>``` bash</p>

<p>  #!/bin/bash
  # Based on <a href="https://github.com/knomedia/ember-cli-rails/blob/master/build.sh">https://github.com/knomedia/ember-cli-rails/blob/master/build.sh</a></p>

<p>  function printMessage {</p>

<pre><code>color=$(tput setaf $1)
message=$2
reset=$(tput sgr0)
echo -e "${color}${message}${reset}"
</code></pre>

<p>  }</p>

<p>  function boldMessage {</p>

<pre><code>color=$(tput setaf $1)
message=$2
reset=$(tput sgr0)
echo -e "${color}*************************************${reset}"
echo -e "${color}${message}${reset}"
echo -e "${color}*************************************${reset}"
</code></pre>

<p>  }</p>

<p>  cd cli-app
  boldMessage 4 &ldquo;Building Ember app&rdquo;</p>

<p>  ember build &mdash;environment production
  cd ../rails/</p>

<p>  rm -rf public/ember-assets</p>

<p>  printMessage 4 &ldquo;Copying ember build files to rails&rdquo;
  cp -r ../cli-app/dist/ public/</p>

<p>  printMessage 4 &ldquo;Swaping assets dir for ember-assets&rdquo;
  mv public/assets public/ember-assets</p>

<p>  printMessage 4 &ldquo;Replacing references s/assets/ember-assets/ in public/index.html&rdquo;
  sed -i .bck s/assets/ember-assets/ public/index.html</p>

<p>  printMessage 4 &ldquo;inserting csrf_meta_tags in head&rdquo;
  sed -i .bck &rsquo;s/&lt;\/head>/&lt;%= csrf_meta_tags %>&amp;/&lsquo; public/index.html</p>

<p>  printMessage 4 &ldquo;inserting yield in body&rdquo;
  sed -i .bck &rsquo;s/<body>/&amp;&lt;%= yield %>/&lsquo; public/index.html</p>

<p>  printMessage 4 &ldquo;Replacing application.html.erb with index.html&rdquo;
  mv public/index.html app/views/layouts/application.html.erb</p>

<p>  printMessage 4 &ldquo;Cleaning Up&rdquo;
  rm -rf public_bk/
  rm public/index.html.bck</p>

<p>  boldMessage 4 &ldquo;Done&rdquo;
```</p>

<p>Now, we can shutdown ember server and visit localhost:3000, we can still see our ember app there.</p>

<p>To deploy our app we need to deploy our rails app only. We can put out both frontend and backend in single repo or in different repo. I have put both in a single <a href="https://github.com/RohitRox/embercli-rails">repo</a>. Do <code>config.serve_static_assets = true</code> in production.rb We can deploy like any other rails app. I have deployed this app to <a href="https://embercli-rails.herokuapp.com/posts">heroku</a>. One gotcha is that heroku expects the app directory structure at the root of the repository. So to deploy we will have to push differently:
<code>
  $ git subtree push --prefix rails heroku master
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Single Table Inheritance in Mongoid]]></title>
    <link href="http://rohitrox.github.io/2013/08/30/single-table-inheritance-in-mongoid/"/>
    <updated>2013-08-30T14:04:00-04:00</updated>
    <id>http://rohitrox.github.io/2013/08/30/single-table-inheritance-in-mongoid</id>
    <content type="html"><![CDATA[<p>Single table inheritance is a software pattern described by Martin Fowler. STI is basically an idea of using a single table(colection in case of mongo) to reflect multiple models that inherit from a base model.</p>

<p>We use STI pattern when we are dealing with classes that have same attributes and behaviour. Rather than duplicate the same code over and over, STI helps us to use a common base model and write specific behaviours in its inherited class while keeeping data on a same table.</p>

<p>Mongoid supports inheritance in both root and embedded documents. In
scenarios where documents are inherited from their fields, relations, validations and scopes get copied down into their child documents, but not vice-versa.</p>

<p>A very simple example:</p>

<p>``` ruby</p>

<pre><code>class Employee
  include Mongoid::Document
  field :name, type: String
  field :employee_code, type: Integer
end

class FullTimeEmployee &lt; Employee
  field status, type: String, default: "Temporary"
end

class InternEmployee &lt; Employee
  field intern_period, type: Integer
end
</code></pre>

<p>```</p>

<!-- more -->


<p>In the above example, both FullTimeEmployee and InternEmployee will be saved in the Employee collection. An additional attribute _type is automatically stored in order to make sure when loaded from the database the correct document is returned.</p>

<p>Following behaviour can be seen, much similar to Single Table Inheritance in ActiveRecord.</p>

<p>``` ruby</p>

<p>  emp1 = Employee.new
  emp2 = FullTimeEmployee.new
  emp3 = InternEmployee.new</p>

<p>  Employee.count
  #=> 3
  FullTimeEmployee.count
  #=> 1
  InternEmployee.count
  #=> 1
  emp1.<em>type
  #=> &ldquo;Employee&rdquo;
  emp2.</em>type
  #=> &ldquo;FullTimeEmployee&rdquo;
  emp3._type
  #=> &ldquo;InternEmployee&rdquo;</p>

<p>  Employee.where(name: &ldquo;&hellip;&rdquo;)
  #=> Returns Employee documents and subclasses
  FullTimeEmployee.where(name: &ldquo;&hellip;&rdquo;)
  #=> returns only FullTimeEmployee documents</p>

<p>```</p>

<p>An advance example:</p>

<p>``` ruby</p>

<pre><code>class Canvas
  include Mongoid::Document
  field :name, type: String
  embeds_many :shapes
end

class Browser &lt; Canvas
  field :version, type: Integer
  scope :recent, where(:version.gt =&gt; 3)
end

class Firefox &lt; Browser
end

class Shape
  include Mongoid::Document
  field :x, type: Integer
  field :y, type: Integer
  embedded_in :canvas
end

class Circle &lt; Shape
  field :radius, type: Float
end

class Rectangle &lt; Shape
  field :width, type: Float
  field :height, type: Float
end
</code></pre>

<p>```</p>

<p>Canvas, Browser and Firefox will all save in the canvases collection.This also holds true for the embedded documents Circle, Rectangle, and Shape.</p>

<p>To query for subclasses within an embedded collection you need to leverage the <em>type attribute in each subclassed object. Canvas and Shape documents, would not have it, but Browser, Firefox, Circle, and Rectangle would. Keep in mind that </em>type is a string that stores the name of the document&rsquo;s class, and as such can only be used to query for a specific subclass, and not anything it is a subclass of.</p>

<p>If, for example, Rectangle was a subclass of Parallelogram which was in turn a subclass of Shape, you could search the Canvas&rsquo;s shapes collection for objects with a _type of &ldquo;Parallelogram&rdquo; but it would never return a Rectangle object, and vice-versa.</p>

<p>``` ruby</p>

<p>  # Returns all the Rectangle shapes in a previously found Canvas
  my_canvas.shapes.where(_type: &ldquo;Rectangle&rdquo;)</p>

<p>  # Returns no entries (see above)
  my_canvas.shapes.where(_type: &ldquo;Shape&rdquo;)</p>

<p>  # Returns all the Canvasas that have Circles
  Canvas.where(&ldquo;shapes._type&rdquo;=>&ldquo;Circle&rdquo;)</p>

<p>  # Returns no entries (see above)
  Canvas.where(&ldquo;shapes._type'=>"Shape&rdquo;)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Up and running Ruby on Rails on Ubuntu]]></title>
    <link href="http://rohitrox.github.io/2013/08/26/up-and-running-ruby-on-rails-on-ubuntu/"/>
    <updated>2013-08-26T22:27:00-04:00</updated>
    <id>http://rohitrox.github.io/2013/08/26/up-and-running-ruby-on-rails-on-ubuntu</id>
    <content type="html"><![CDATA[<h3>6 steps for setting ruby on rails development environment in Ubuntu.</h3>

<h3>Step 1: Setting up RVM</h3>

<p>``` bash</p>

<pre><code>$ sudo apt-get update
$ sudo apt-get install curl
$ curl -L https://get.rvm.io | bash -s stable
$ source ~/.rvm/scripts/rvm 
</code></pre>

<p>```</p>

<p>In order to work, RVM has some of its own dependancies that need to be installed. You can see what these are:</p>

<p>``` bash</p>

<pre><code>$ rvm requirements
# In the text that RVM shows you, look for this paragraph.
# Additional Dependencies:
# For ruby:
# apt-get --no-install-recommends install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev  libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev ncurses-dev automake libtool bison subversion pkg-config libffi-dev
# Just follow the instructions to get your system up to date with all of the required dependancies.
$ sudo apt-get --no-install-recommends install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev ncurses-dev automake libtool bison subversion pkg-config libffi-dev
</code></pre>

<p>```
Then</p>

<p>``` bash</p>

<pre><code>$ echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" &gt;&gt; ~/.bash_profile
# or 
$ echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; source "$HOME/.rvm/scripts/rvm" &gt;&gt; ~/.bashrc
</code></pre>

<p>```</p>

<h3>Step 2: Install ruby</h3>

<p>``` bash</p>

<pre><code>$ rvm install 1.9.3
# after success you can verify your installation by 
$ rvm list
# should output something like 
# rvm rubies
# =* ruby-1.9.3-p362 [ i686 ]
</code></pre>

<p>```</p>

<h3>Step 3: RubyGems</h3>

<p>``` bash</p>

<pre><code>$ rvm rubygems current
</code></pre>

<p>```</p>

<h3>Step 4: Rails</h3>

<p>``` bash</p>

<pre><code># a Javascript runtime, NodeJs
$ sudo add-apt-repository ppa:chris-lea/node.js
$ sudo apt-get update
$ sudo apt-get install nodejs

$ gem install bundler
$ gem install rails
</code></pre>

<p>```</p>

<h3>Step 5: First Rails app</h3>

<p>```</p>

<pre><code>$ rails new my_app
$ cd my_app
$ bundle install
$ rails s
# open browser and visit localhost:3000
# you should see the famous welcome abroad page
</code></pre>

<p>```</p>

<h3>Step 6: Development Extras</h3>

<h4>Sublime Text 2</h4>

<p>``` bash</p>

<pre><code>$ sudo add-apt-repository ppa:webupd8team/sublime-text-2
$ sudo apt-get update
$ sudo apt-get install sublime-text
</code></pre>

<p>```
Install sublime package manager from <a href="http://wbond.net/sublime_packages/package_control/installation">here</a> for other sublime goodies.</p>

<h4>Configure Vim for Rails</h4>

<p>``` bash</p>

<pre><code>$ curl -Lo- https://bit.ly/janus-bootstrap | bash
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Canvas Images and Rails]]></title>
    <link href="http://rohitrox.github.io/2013/07/19/canvas-images-and-rails/"/>
    <updated>2013-07-19T15:15:00-04:00</updated>
    <id>http://rohitrox.github.io/2013/07/19/canvas-images-and-rails</id>
    <content type="html"><![CDATA[<p>With the introduction of Canvas, HTML5 has empower us to draw shapes, graphs, render texts, make gradients and patterns, manipulate images pixels, set an animations, even creating a stunning games!
All this stuffs occur on the client side in the browsers.
So let say you make an app that render some effects in a Canvas element and you want to allow user to take screenshot of the resut or save the result in your server for yourself.</p>

<p>Let&rsquo;s digg how can we do it and save that canvas as an image in ther server using Rails.</p>

<h3>Strategy 1 : Send canvas image as raw dataURL</h3>

<p>The data URI scheme is a URI scheme that provides a way to include data in-line in web pages as if they were external resources. The <code>canvas.toDataURL()</code> method returns the image data of the canvas as Data URI. And the Data URI has the image data Encodes with MIME base64.</p>

<p>Let&rsquo;s see how it works. Copy and run this javascript snippet in your browser console. Somewhere at the bottom of the page you&rsquo;ll see a green circle.</p>

<p>``` javascript</p>

<pre><code>var canvas = document.createElement('canvas');
var context = canvas.getContext('2d');
var centerX = canvas.width / 2;
var centerY = canvas.height / 2;
var radius = 70;

context.beginPath();
context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
context.fillStyle = 'green';
context.fill();
context.lineWidth = 5;
context.strokeStyle = '#003300';
context.stroke();

document.body.appendChild(canvas)
</code></pre>

<p>```
Now lets render that canvas as an image.</p>

<p>``` javascript</p>

<pre><code>var dataURL =  canvas.toDataURL('image/png');
window.location = dataURL;
</code></pre>

<p>```</p>

<!--more-->


<p>As you can see, with that weird long url string something like <code>data:image/png;base64,iVBORw0KGgoA...</code>, it render a png image. That long url is infact data uri which has image data encoded with MIME base64.</p>

<p>The format to be specific is <strong><em> data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt; encoded data &gt; </em></strong>.</p>

<p>Now, if we want to save that image in the server, we can just send that data uri as normal params and at the server, we can use ruby to decode that save that data as image file.</p>

<p>``` ruby</p>

<pre><code>require 'base64'

data = params[:data_uri]
// remove all extras except data
image_data = Base64.decode64(data['data:image/png;base64,'.length .. -1])

File.open("#{Rails.root}/public/uploads/somefilename.png", 'wb') do |f|
  f.write image_data
end
</code></pre>

<p>```</p>

<h3>Strategy 2 : Send It as a Blob object</h3>

<p>This method also use the dataURL but instead of send it as a raw text, we convert it to an image file object and send it.
For this we use the Blob object. Simply it&rsquo;s an object that represent a file-like object, so we create a blob object with the type PNG image, after we append this blob object to a FormData, and finally we send it through the jQuery Ajax Method.</p>

<p>Let&rsquo;s detail a bit what I say above, we already see how we get the dataURL from an object, the dataURL is only a raw text, so we need to decode it to a binary data, we already know that the type of the encoding in the dataURL is Base64, and for decode it using a JavaScript solution we use the predefined atob method, now after decoding it we get a binary data, and we need to convert it to an array where there element is a 8-bit unsigned integer values. Finally we have to put this array in a new Uint8Array object for pass it to our Blob object that represent our file, now let create a function that do this and convert our Canvas to a blob object:</p>

<p>``` javascript</p>

<pre><code>// Convert dataURL to Blob object
function dataURLtoBlob(dataURL) {
  // Decode the dataURL    
  var binary = atob(dataURL.split(',')[1]);
  // Create 8-bit unsigned array
  var array = [];
  for(var i = 0; i &lt; binary.length; i++) {
      array.push(binary.charCodeAt(i));
  }
  // Return our Blob object
  return new Blob([new Uint8Array(array)], {type: 'image/png'});
}
</code></pre>

<p>```</p>

<p>We can now create a new FormData object, put our file on it and send our data using Ajax.</p>

<p>``` javascript</p>

<pre><code>// Get our file
var file= dataURLtoBlob(dataURL);
// Create new form data
var fd = new FormData();
// Append our Canvas image file to the form data
fd.append("image", file);
// And send it
$.ajax({
   url: "/screenshot",
   type: "POST",
   data: fd,
   processData: false,
   contentType: false,
});
</code></pre>

<p>```</p>

<p>At controller:</p>

<p>``` ruby</p>

<pre><code>File.open("#{Rails.root}/public/uploads/somefilename.png", 'wb') do |f|
  f.write(params[:image].read)
end
</code></pre>

<p>```</p>

<p>So, that&rsquo;s it.</p>

<p>This method is more appropriate and faster than the first one.</p>

<p>Those wondering how to mix this with carrierwave and paperclip, here are the links:</p>

<p><a href="http://stackoverflow.com/questions/14900038/rails-carrierwave-iphone-base64-image-upload">Rails carrierwave base-64 encoded image upload</a></p>

<p><a href="https://gist.github.com/WizardOfOgz/1012107">Base64-encoded images with Paperclip</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature flippers with rollout]]></title>
    <link href="http://rohitrox.github.io/2013/03/18/feature-flippers-with-rollout/"/>
    <updated>2013-03-18T12:09:00-04:00</updated>
    <id>http://rohitrox.github.io/2013/03/18/feature-flippers-with-rollout</id>
    <content type="html"><![CDATA[<p>Rollout gem comes handy when we need deploy a beta feature, may be to a selected group of users or some percentage of uses so that few users can try it out before it goes massive.</p>

<p>So lets rollout.</p>

<p>First of all, make sure that you have redis, because rollout uses redis as its backend. Then add <code>gem 'rollout'</code> to gemfile and bundle install.</p>

<p>Now, we need to create a rollout setup file inside initializer.</p>

<p>Let&rsquo;s name it rollout_init.rb which looks like this:</p>

<p>```ruby</p>

<p>  $redis = Redis.new
  $rollout = Rollout.new($redis)
  $rollout.define_group(:admin) do |user|</p>

<pre><code>user.admin?
</code></pre>

<p>  end</p>

<p>```
Documentation suggests to use a global variables. So we create one with a new redis instance.
Then, we create rollout instance passsing that redis instance. We can configure rollout in many ways, here we are defining an admin group by passing a block and checking whether the user belongs to that group or not.
Complete documentation can be found <a href="https://github.com/jamesgolick/rollout">here</a>.</p>

<p>Next, we can now use handy rollout method like for example let&rsquo;s say we need to activate chat feature for admin group only.</p>

<p>``` ruby</p>

<p>  if $rollout.active? :chat, current_user</p>

<pre><code>....
</code></pre>

<p>  end</p>

<p>```</p>

<!--more-->


<p>The <code>$rollout.active?</code> method accepts the name of the feature and the user and returns true or false.</p>

<p>This method is accessible in views as well as in controllers.
That&rsquo;s not all, if you restart your server now and look at the app, you may find out that the feature is unavailable to admin groups also, it is because by default the feature is deactivated to all groups or users. We can make a rake task or an interface for activating the feature to subset of users. Activating code looks like this:</p>

<p>``` ruby</p>

<p>  $rollout.activate_group(:chat, :admin)</p>

<p>```
This will activate the feature ( chat in our case ) for admin group.</p>

<p>Also we can activate the feature to all users or specific user or to some percentage.</p>

<p>``` ruby</p>

<p>  $rollout.activate_group( :chat, :all ) #activate to all, there is all group already by default</p>

<p>  $rollout.activate_user( :chat, User.find_by_email(&ldquo;<a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x61;&#100;&#109;&#105;&#x6e;&#x40;&#109;&#x79;&#x61;&#x70;&#112;&#x2e;&#99;&#x6f;&#x6d;">&#x61;&#100;&#109;&#x69;&#110;&#64;&#x6d;&#x79;&#x61;&#x70;&#112;&#x2e;&#x63;&#x6f;&#x6d;</a>&rdquo;) ) #activate to specific user</p>

<p>  $rollout.activate_percantage( :chat, 50 ) #activate to 50% of users</p>

<p>```</p>

<p>Each of these methods have deactivate version for deactivating the feature. You can also just call <code>$rollout.deactivate_all(:chat)</code> to deactivate the feature to all at once.</p>
]]></content>
  </entry>
  
</feed>
